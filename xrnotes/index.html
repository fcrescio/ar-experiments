<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>XR Notes</title>
  <style>
    :root {
      color-scheme: light dark;
      --panel-bg: rgba(0, 0, 0, 0.55);
      --panel-border: rgba(255, 255, 255, 0.15);
      --accent: #7dd3fc;
    }
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, sans-serif;
      background: #000;
      color: #fff;
    }
    #session {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 6px 10px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      font-size: 12px;
      opacity: 0.85;
      z-index: 10;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="session"></div>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // Session identity -------------------------------------------------------
    const sessionKey = 'xrnotes-session-id';
    const sessionId = (() => {
      const existing = localStorage.getItem(sessionKey);
      if (existing) return existing;
      const random = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(16).slice(2);
      localStorage.setItem(sessionKey, random);
      return random;
    })();
    document.getElementById('session').textContent = `Session: ${sessionId}`;

    // Three.js setup ---------------------------------------------------------
    let scene, camera, renderer;
    let reticle, hitTestSource = null, hitTestSourceRequested = false;
    const raycaster = new THREE.Raycaster();
    const tempMatrix = new THREE.Matrix4();
    const tempVec = new THREE.Vector3();

    // Controllers ------------------------------------------------------------
    const controllers = [];
    let leftHandPanel = null;
    const panelButtons = new Map();

    // Notes data -------------------------------------------------------------
    const notes = new Map();
    const lines = new Set();
    let connectFirst = null;
    let noteCounter = 1;

    // Audio ------------------------------------------------------------------
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;
    let recordingTarget = null;

    // Utility ----------------------------------------------------------------
    const COLOR_POOL = [0x7dd3fc, 0xa78bfa, 0xf472b6, 0xf97316, 0xf97316, 0x22c55e, 0x38bdf8];
    const pickColor = () => COLOR_POOL[Math.floor(Math.random() * COLOR_POOL.length)];

    function setStatus(message) {
      console.log('[XRNotes]', message);
    }

    function setNoteHighlight(mesh, active) {
      if (mesh?.material?.emissive) {
        mesh.material.emissive.setHex(active ? 0x222222 : 0x000000);
      }
    }

    // Recording --------------------------------------------------------------
    async function startRecordingFor(note) {
      if (!navigator.mediaDevices?.getUserMedia || isRecording) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(stream);
        recordingTarget = note;
        mediaRecorder.ondataavailable = (e) => recordedChunks.push(e.data);
        mediaRecorder.onstop = async () => {
          try {
            const blob = new Blob(recordedChunks, { type: 'audio/webm' });
            const buffer = await blob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(buffer.slice(0));
            note.userData.audioBuffer = audioBuffer;
            setStatus(`Recorded audio for ${note.userData.label}.`);
          } catch (err) {
            console.error(err);
            setStatus('Failed to decode recorded audio.');
          } finally {
            stream.getTracks().forEach((t) => t.stop());
          }
        };
        mediaRecorder.start();
        isRecording = true;
        setStatus(`Recording on ${note.userData.label}...`);
      } catch (err) {
        console.error(err);
        setStatus('Could not start recording. Microphone permission is required.');
      }
    }

    function stopRecording() {
      if (!isRecording || !mediaRecorder) return;
      mediaRecorder.stop();
      isRecording = false;
      recordingTarget = null;
    }

    // Notes creation ---------------------------------------------------------
    function createNoteMesh(position) {
      const id = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(16).slice(2);
      const label = `Note ${noteCounter++}`;
      const geometry = new THREE.SphereGeometry(0.055, 32, 32);
      const material = new THREE.MeshStandardMaterial({ color: pickColor(), roughness: 0.4, metalness: 0.05 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(position);
      mesh.userData = { id, label, audioBuffer: null };
      scene.add(mesh);
      notes.set(id, mesh);
      refreshPanel();
      setStatus(`${label} placed.`);
      return mesh;
    }

    function placeNoteAtReticle() {
      if (!reticle.visible) return null;
      tempVec.setFromMatrixPosition(reticle.matrix);
      return createNoteMesh(tempVec);
    }

    function placeNoteAtController(controller) {
      controller.getWorldPosition(tempVec);
      return createNoteMesh(tempVec);
    }

    function playNote(mesh) {
      const buffer = mesh.userData.audioBuffer;
      if (!buffer) return;
      const src = audioContext.createBufferSource();
      src.buffer = buffer;
      src.connect(audioContext.destination);
      src.start();
    }

    function removeNote(mesh) {
      const id = mesh.userData.id;
      scene.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
      notes.delete(id);
      for (const line of Array.from(lines)) {
        if (line.userData.ids.includes(id)) {
          scene.remove(line);
          line.geometry.dispose();
          line.material.dispose();
          lines.delete(line);
        }
      }
      if (recordingTarget === mesh) stopRecording();
      refreshPanel();
    }

    // Connection -------------------------------------------------------------
    function connectNotes(a, b) {
      const points = [a.position.clone(), b.position.clone()];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
      const line = new THREE.Line(geometry, material);
      line.userData.ids = [a.userData.id, b.userData.id];
      scene.add(line);
      lines.add(line);
    }

    function updateLineGeometry(line) {
      const [idA, idB] = line.userData.ids;
      const a = notes.get(idA);
      const b = notes.get(idB);
      if (!a || !b) return;
      const positions = new Float32Array([
        a.position.x, a.position.y, a.position.z,
        b.position.x, b.position.y, b.position.z
      ]);
      line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      line.geometry.computeBoundingSphere();
    }

    // Selection & interactions ----------------------------------------------
    function setSelection(mesh) {
      if (connectFirst && connectFirst !== mesh) {
        connectNotes(connectFirst, mesh);
        connectFirst = null;
        return;
      }
      connectFirst = mesh;
      setStatus(`${mesh.userData.label} selected. Choose another to connect.`);
    }

    function updateHover(controller) {
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      const intersects = raycaster.intersectObjects(Array.from(notes.values()));
      const previous = controller.userData.hovered;
      const next = intersects[0]?.object ?? null;
      if (previous && previous !== next) {
        setNoteHighlight(previous, false);
      }
      if (next && next !== previous) {
        setNoteHighlight(next, true);
      }
      controller.userData.hovered = next?.userData?.isPanelButton ? null : next;
      return controller.userData.hovered;
    }

    function handleSelect(controller) {
      const hovered = controller.userData.hovered;
      if (isRecording) return;
      if (hovered?.userData?.isPanelButton) {
        recallNote(hovered.userData.noteId);
        return;
      }
      if (hovered) {
        setSelection(hovered);
        playNote(hovered);
        return;
      }
      const placed = placeNoteAtReticle();
      if (placed) {
        setSelection(placed);
      }
    }

    function handleSelectStart(controller) {
      const hovered = controller.userData.hovered;
      if (hovered && !hovered.userData?.isPanelButton) {
        startRecordingFor(hovered);
      }
    }

    function handleSelectEnd() {
      if (isRecording) stopRecording();
    }

    function recallNote(id) {
      const mesh = notes.get(id);
      if (!mesh) return;
      camera.getWorldDirection(tempVec);
      tempVec.normalize().multiplyScalar(0.6);
      const targetPos = new THREE.Vector3();
      targetPos.copy(camera.position).add(tempVec);
      mesh.position.copy(targetPos);
      for (const line of lines) {
        if (line.userData.ids.includes(id)) updateLineGeometry(line);
      }
      setStatus(`${mesh.userData.label} moved in front of you.`);
    }

    function makePanelEntry(note) {
      const width = 0.24;
      const height = 0.05;
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(20,20,20,0.9)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#7dd3fc';
      ctx.font = 'bold 36px system-ui';
      ctx.fillText(note.userData.label, 16, 48);
      ctx.fillStyle = '#fff';
      ctx.font = '28px system-ui';
      ctx.fillText('Recall', 16, 100);
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
      const geometry = new THREE.PlaneGeometry(width, height);
      const mesh = new THREE.Mesh(geometry, material);
      mesh.userData = { noteId: note.userData.id, isPanelButton: true };
      return mesh;
    }

    function refreshPanel() {
      if (!leftHandPanel) return;
      panelButtons.forEach((mesh) => leftHandPanel.remove(mesh));
      panelButtons.clear();
      let y = 0.08;
      for (const note of notes.values()) {
        const btn = makePanelEntry(note);
        btn.position.set(0, y, 0);
        leftHandPanel.add(btn);
        panelButtons.set(note.userData.id, btn);
        y -= 0.07;
      }
    }

    function updatePanelAttachment() {
      const left = controllers.find((c) => c.userData.handedness === 'left');
      if (!left || leftHandPanel) return;
      const grip = renderer.xr.getControllerGrip(left.userData.index);
      leftHandPanel = new THREE.Group();
      const background = new THREE.Mesh(
        new THREE.PlaneGeometry(0.3, 0.32),
        new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.6, transparent: true })
      );
      background.position.set(0, 0.03, -0.04);
      leftHandPanel.add(background);
      leftHandPanel.position.set(0.05, 0.12, -0.15);
      grip.add(leftHandPanel);
      refreshPanel();
    }

    function panelRaycast(controller) {
      if (!leftHandPanel) return null;
      const objects = Array.from(panelButtons.values());
      if (!objects.length) return null;
      const origin = new THREE.Vector3();
      const direction = new THREE.Vector3(0, 0, -1);
      origin.setFromMatrixPosition(controller.matrixWorld);
      direction.applyMatrix4(tempMatrix.identity().extractRotation(controller.matrixWorld));
      raycaster.set(origin, direction);
      const hits = raycaster.intersectObjects(objects, true);
      return hits[0]?.object ?? null;
    }

    // XR initialization ------------------------------------------------------
    function init() {
      scene = new THREE.Scene();
      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.7));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      dirLight.position.set(1, 1.5, 1);
      scene.add(dirLight);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      document.body.appendChild(
        ARButton.createButton(renderer, {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        })
      );

      const ringGeo = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI / 2);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0x7dd3fc, side: THREE.DoubleSide, opacity: 0.9, transparent: true });
      reticle = new THREE.Mesh(ringGeo, ringMat);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      for (let i = 0; i < 2; i++) {
        const controller = renderer.xr.getController(i);
        controller.userData.index = i;
        controller.userData.hovered = null;
        controller.userData.buttonAPressed = false;
        controller.addEventListener('select', () => handleSelect(controller));
        controller.addEventListener('selectstart', () => handleSelectStart(controller));
        controller.addEventListener('selectend', handleSelectEnd);
        controller.addEventListener('connected', (event) => {
          controller.userData.handedness = event.data.handedness;
          controller.userData.gamepad = event.data.gamepad;
          updatePanelAttachment();
        });
        controller.addEventListener('disconnected', () => {
          controller.userData.gamepad = null;
        });
        scene.add(controller);
        controllers.push(controller);
      }

      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();
        if (!hitTestSourceRequested) {
          session.requestReferenceSpace('viewer').then((referenceSpace) => {
            session.requestHitTestSource({ space: referenceSpace }).then((source) => {
              hitTestSource = source;
            });
          });
          session.addEventListener('end', () => {
            hitTestSourceRequested = false;
            hitTestSource = null;
          });
          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      // Controller driven interactions
      for (const controller of controllers) {
        updateHover(controller);
        const btn = panelRaycast(controller);
        if (btn && controller.userData.hovered !== btn) {
          controller.userData.hovered = btn;
        }

        const gamepad = controller.userData.gamepad;
        const aPressed = gamepad?.buttons?.[4]?.pressed;
        if (aPressed && !controller.userData.buttonAPressed) {
          placeNoteAtController(controller);
        }
        controller.userData.buttonAPressed = !!aPressed;
      }

      // Update lines if controllers moved selected points
      for (const line of lines) {
        updateLineGeometry(line);
      }

      renderer.render(scene, camera);
    }

    init();
    animate();
  </script>
</body>
</html>
