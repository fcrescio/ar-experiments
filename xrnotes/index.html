<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>XR Notes</title>
  <style>
    :root {
      color-scheme: light dark;
      --panel-bg: rgba(0, 0, 0, 0.55);
      --panel-border: rgba(255, 255, 255, 0.15);
      --accent: #7dd3fc;
    }
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, sans-serif;
      background: #000;
      color: #fff;
    }
    #ui {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      border-radius: 12px;
      backdrop-filter: blur(8px);
      max-width: 360px;
      z-index: 10;
    }
    #status {
      font-size: 13px;
      line-height: 1.4;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
    }
    button {
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.1);
      color: inherit;
      border: 1px solid var(--panel-border);
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
    }
    button:hover {
      background: rgba(255, 255, 255, 0.18);
    }
    button.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(125, 211, 252, 0.45);
    }
    #session {
      font-size: 12px;
      opacity: 0.8;
    }
    #reticleHint {
      font-size: 12px;
      color: #fbbf24;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="ui">
    <div><strong>XR Notes</strong> ‚Äî spatial audio stickies</div>
    <div id="session"></div>
    <div id="status">Load AR, look for the reticle, then record a note and place it in space.</div>
    <div id="reticleHint" hidden>Move your device to find a surface...</div>
    <div class="controls">
      <button id="record">üéôÔ∏è Start recording</button>
      <button id="move" disabled>Move selected</button>
      <button id="connect" disabled>Connect notes</button>
    </div>
    <div class="controls">
      <button id="clear" disabled>Clear selection</button>
      <button id="delete" disabled>Delete selected</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { ARButton } from 'three/addons/webxr/ARButton.js';

    // Session identity -------------------------------------------------------
    const sessionKey = 'xrnotes-session-id';
    const sessionId = (() => {
      const existing = localStorage.getItem(sessionKey);
      if (existing) return existing;
      const random = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(16).slice(2);
      localStorage.setItem(sessionKey, random);
      return random;
    })();
    document.getElementById('session').textContent = `Session: ${sessionId}`;

    // DOM references ---------------------------------------------------------
    const statusEl = document.getElementById('status');
    const reticleHint = document.getElementById('reticleHint');
    const recordBtn = document.getElementById('record');
    const moveBtn = document.getElementById('move');
    const connectBtn = document.getElementById('connect');
    const clearBtn = document.getElementById('clear');
    const deleteBtn = document.getElementById('delete');

    // Three.js setup ---------------------------------------------------------
    let scene, camera, renderer, controller;
    let reticle, hitTestSource = null, hitTestSourceRequested = false;
    const raycaster = new THREE.Raycaster();
    const tempMatrix = new THREE.Matrix4();

    // Notes data -------------------------------------------------------------
    const notes = new Map();
    const lines = new Set();
    let selectedNote = null;
    let connectFirst = null;

    // Audio ------------------------------------------------------------------
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    let mediaRecorder = null;
    let recordedChunks = [];
    let isRecording = false;

    // Utility ----------------------------------------------------------------
    const COLOR_POOL = [0x7dd3fc, 0xa78bfa, 0xf472b6, 0xf97316, 0x22c55e, 0x38bdf8];
    const pickColor = () => COLOR_POOL[Math.floor(Math.random() * COLOR_POOL.length)];

    function setStatus(message) {
      statusEl.textContent = message;
    }

    function setButtons() {
      moveBtn.disabled = !selectedNote;
      connectBtn.disabled = notes.size < 2;
      clearBtn.disabled = !selectedNote && !connectFirst;
      deleteBtn.disabled = !selectedNote;
      connectBtn.classList.toggle('active', !!connectFirst);
    }

    // Recording --------------------------------------------------------------
    async function startRecording() {
      if (!navigator.mediaDevices?.getUserMedia) {
        setStatus('Audio recording is not supported in this browser.');
        return;
      }
      if (isRecording) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = (e) => recordedChunks.push(e.data);
        mediaRecorder.onstop = async () => {
          const blob = new Blob(recordedChunks, { type: 'audio/webm' });
          const buffer = await blob.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(buffer.slice(0));
          placeNote(audioBuffer);
          stream.getTracks().forEach((t) => t.stop());
        };
        mediaRecorder.start();
        isRecording = true;
        recordBtn.textContent = '‚èπÔ∏è Stop recording';
        setStatus('Recording... tap stop to place the note at the reticle.');
      } catch (err) {
        console.error(err);
        setStatus('Could not start recording. Microphone permission is required.');
      }
    }

    function stopRecording() {
      if (!isRecording || !mediaRecorder) return;
      mediaRecorder.stop();
      isRecording = false;
      recordBtn.textContent = 'üéôÔ∏è Start recording';
    }

    // Notes creation ---------------------------------------------------------
    function placeNote(audioBuffer) {
      if (!reticle.visible) {
        setStatus('Look for a surface: the reticle must be visible to place a note.');
        return;
      }
      const id = crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(16).slice(2);
      const geometry = new THREE.SphereGeometry(0.055, 32, 32);
      const material = new THREE.MeshStandardMaterial({ color: pickColor(), roughness: 0.4, metalness: 0.05 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.setFromMatrixPosition(reticle.matrix);
      mesh.userData = { id, audioBuffer };
      scene.add(mesh);
      notes.set(id, mesh);
      setStatus('Note placed. Tap it to play, move, or connect.');
      setButtons();
    }

    function playNote(mesh) {
      const buffer = mesh.userData.audioBuffer;
      if (!buffer) return;
      const src = audioContext.createBufferSource();
      src.buffer = buffer;
      src.connect(audioContext.destination);
      src.start();
    }

    function removeNote(mesh) {
      const id = mesh.userData.id;
      scene.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
      notes.delete(id);
      // remove lines involving this note
      for (const line of Array.from(lines)) {
        if (line.userData.ids.includes(id)) {
          scene.remove(line);
          line.geometry.dispose();
          line.material.dispose();
          lines.delete(line);
        }
      }
      if (selectedNote === mesh) selectedNote = null;
      if (connectFirst === mesh) connectFirst = null;
      setButtons();
      setStatus('Note removed.');
    }

    // Connection -------------------------------------------------------------
    function connectNotes(a, b) {
      const points = [a.position.clone(), b.position.clone()];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
      const line = new THREE.Line(geometry, material);
      line.userData.ids = [a.userData.id, b.userData.id];
      scene.add(line);
      lines.add(line);
      setStatus('Notes connected.');
    }

    function updateLineGeometry(line) {
      const [idA, idB] = line.userData.ids;
      const a = notes.get(idA);
      const b = notes.get(idB);
      if (!a || !b) return;
      const positions = new Float32Array([
        a.position.x, a.position.y, a.position.z,
        b.position.x, b.position.y, b.position.z
      ]);
      line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      line.geometry.computeBoundingSphere();
    }

    // Selection & interactions ----------------------------------------------
    function setSelection(mesh) {
      if (selectedNote === mesh) return;
      if (selectedNote) selectedNote.material.emissive?.setHex?.(0x000000);
      selectedNote = mesh;
      if (mesh?.material?.emissive) {
        mesh.material.emissive.setHex(0x111111);
      }
      moveBtn.disabled = !selectedNote;
      deleteBtn.disabled = !selectedNote;
      clearBtn.disabled = !selectedNote && !connectFirst;
    }

    function clearSelection() {
      if (selectedNote?.material?.emissive) {
        selectedNote.material.emissive.setHex(0x000000);
      }
      selectedNote = null;
      connectFirst = null;
      setButtons();
      setStatus('Selection cleared.');
    }

    function onSelect() {
      // Raycast vs notes first
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      const intersects = raycaster.intersectObjects(Array.from(notes.values()));

      if (intersects.length > 0) {
        const mesh = intersects[0].object;
        playNote(mesh);
        if (connectFirst && connectFirst !== mesh) {
          connectNotes(connectFirst, mesh);
          connectFirst = null;
          connectBtn.classList.remove('active');
        } else {
          setSelection(mesh);
        }
        setButtons();
        return;
      }

      if (!reticle.visible) {
        setStatus('Move your device to find a surface to place or move notes.');
        return;
      }

      if (selectedNote) {
        selectedNote.position.setFromMatrixPosition(reticle.matrix);
        for (const line of lines) {
          if (line.userData.ids.includes(selectedNote.userData.id)) {
            updateLineGeometry(line);
          }
        }
        setStatus('Note moved to new position.');
      }
    }

    // XR initialization ------------------------------------------------------
    function init() {
      scene = new THREE.Scene();
      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.7));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      dirLight.position.set(1, 1.5, 1);
      scene.add(dirLight);

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      document.body.appendChild(
        ARButton.createButton(renderer, {
          requiredFeatures: ['hit-test'],
          optionalFeatures: ['dom-overlay'],
          domOverlay: { root: document.body }
        })
      );

      const ringGeo = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI / 2);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0x7dd3fc, side: THREE.DoubleSide, opacity: 0.9, transparent: true });
      reticle = new THREE.Mesh(ringGeo, ringMat);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();
        if (!hitTestSourceRequested) {
          session.requestReferenceSpace('viewer').then((referenceSpace) => {
            session.requestHitTestSource({ space: referenceSpace }).then((source) => {
              hitTestSource = source;
            });
          });
          session.addEventListener('end', () => {
            hitTestSourceRequested = false;
            hitTestSource = null;
          });
          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
            reticleHint.hidden = true;
          } else {
            reticle.visible = false;
            reticleHint.hidden = false;
          }
        }
      }

      renderer.render(scene, camera);
    }

    // UI bindings ------------------------------------------------------------
    recordBtn.addEventListener('click', () => {
      if (!isRecording) {
        startRecording();
      } else {
        stopRecording();
      }
    });

    moveBtn.addEventListener('click', () => {
      if (!selectedNote) return;
      setStatus('Aim at a new spot and tap the screen/controller to move the note.');
    });

    connectBtn.addEventListener('click', () => {
      if (!selectedNote) {
        setStatus('Select a note first, then tap Connect.');
        return;
      }
      connectFirst = selectedNote;
      connectBtn.classList.add('active');
      setStatus('Select another note to draw a line between them.');
      setButtons();
    });

    clearBtn.addEventListener('click', clearSelection);

    deleteBtn.addEventListener('click', () => {
      if (selectedNote) removeNote(selectedNote);
    });

    setButtons();
    init();
    animate();
  </script>
</body>
</html>
