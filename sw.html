[200~<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <title>WebXR - Drone di allenamento (con debug)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
        color: #fff;
        font-family: system-ui, sans-serif;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        padding: 10px 14px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 6px;
        max-width: 260px;
        z-index: 10;
        font-size: 13px;
      }
      #info strong {
        color: #7cf9ff;
      }
      /* il pannello di debug viene creato via JS */
    </style>
  </head>
  <body>
    <div id="info">
      <strong>Drone di allenamento XR</strong><br />
      â€¢ Metti il visore e premi "Enter VR".<br />
      â€¢ Il drone sferico gira intorno a te e spara.<br />
      â€¢ Usa la spada di energia per deviare i colpi.
    </div>

    <script type="module">
      // === SWITCH GLOBALE DI DEBUG ===
      const DEBUG = true; // <-- metti false prima di andare in produzione

      import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
      import { VRButton } from 'https://unpkg.com/three@0.161.0/examples/jsm/webxr/VRButton.js';

      // --- SCENA BASE ---
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      // --- LUCI ---
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x080820, 0.7);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 10, 7);
      scene.add(dirLight);

      // --- PAVIMENTO ---
      const floorGeo = new THREE.CircleGeometry(10, 32);
      const floorMat = new THREE.MeshPhongMaterial({
        color: 0x111111,
        side: THREE.DoubleSide,
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = 0;
      scene.add(floor);

      // --- ATMOSFERA ---
      scene.fog = new THREE.FogExp2(0x000000, 0.08);

      // --- DRONE SFERICO ---
      const droneRadius = 0.15;
      const droneGeo = new THREE.SphereGeometry(droneRadius, 24, 24);
      const droneMat = new THREE.MeshPhongMaterial({
        color: 0x00ffcc,
        emissive: 0x008877,
        shininess: 80,
      });
      const drone = new THREE.Mesh(droneGeo, droneMat);

      const droneGroup = new THREE.Group();
      droneGroup.add(drone);
      scene.add(droneGroup);

      let droneAngle = 0;
      const droneOrbitRadius = 1.8;
      const droneHeight = 1.6;
      const droneAngularSpeed = 0.7; // rad/s

      // --- COLPI DI ENERGIA ---
      const bolts = [];
      const boltSpeed = 4.0; // m/s
      const boltGeo = new THREE.SphereGeometry(0.03, 8, 8);
      const boltMat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });

      let shootTimer = 0;
      const shootInterval = 1.6; // secondi fra un colpo e l'altro

      // --- CONTROLLER E SPADA DI ENERGIA ---
      const controller = renderer.xr.getController(0);
      scene.add(controller);

      const saberLength = 1.0;
      const saberThickness = 0.03;
      const SABER_EFFECTIVE_RADIUS = saberLength * 0.5; // usato anche nel debug

      const saberGeo = new THREE.CylinderGeometry(
        saberThickness,
        saberThickness,
        saberLength,
        8
      );
      const saberMat = new THREE.MeshBasicMaterial({
        color: 0x66ccff,
        transparent: true,
        opacity: 0.9,
      });
      const saber = new THREE.Mesh(saberGeo, saberMat);
      saber.rotation.z = Math.PI / 2; // stesa in avanti
      saber.position.y = 0.0;

      const saberHolder = new THREE.Group();
      saberHolder.add(saber);
      controller.add(saberHolder);

      const hiltGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.2, 8);
      const hiltMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
      const hilt = new THREE.Mesh(hiltGeo, hiltMat);
      hilt.position.y = -0.5;
      saberHolder.add(hilt);

      const reflectedColor = 0x00ff44;

      // --- VETTORI TEMPORANEI ---
      const tmpCameraWorldPos = new THREE.Vector3();
      const tmpSaberWorldPos = new THREE.Vector3();
      const tmpSaberDir = new THREE.Vector3();
      const tmpBoltDir = new THREE.Vector3();
      const tmpDroneWorldPos = new THREE.Vector3();

      // === SEZIONE DEBUG: STATO E STRUMENTI ===
      const debugState = {
        enabled: DEBUG,
        panel: null,
        lines: [],
        maxLines: 7,
        controllerHelper: null,
        saberCollisionHelper: null,
        droneOrbitLine: null,
      };

      function debugLog(msg) {
        if (!debugState.enabled || !debugState.panel) return;
        debugState.lines.push(msg);
        if (debugState.lines.length > debugState.maxLines) {
          debugState.lines.shift();
        }
        debugState.panel.textContent = debugState.lines.join('\n');
      }

      function setupDebug() {
        if (!debugState.enabled) return;

        // Pannellino HTML in alto a destra
        const panel = document.createElement('pre');
        panel.id = 'debugPanel';
        panel.style.position = 'absolute';
        panel.style.right = '10px';
        panel.style.top = '10px';
        panel.style.padding = '8px 10px';
        panel.style.background = 'rgba(0, 0, 0, 0.6)';
        panel.style.color = '#0f0';
        panel.style.fontSize = '11px';
        panel.style.fontFamily = 'monospace';
        panel.style.whiteSpace = 'pre';
        panel.style.zIndex = '20';
        document.body.appendChild(panel);
        debugState.panel = panel;

        // Assi di debug sul controller
        const controllerHelper = new THREE.AxesHelper(0.25);
        controller.add(controllerHelper);
        debugState.controllerHelper = controllerHelper;

        // Sfera di collisione attesa per la spada
        const saberCollisionGeo = new THREE.SphereGeometry(
          SABER_EFFECTIVE_RADIUS,
          16,
          16
        );
        const saberCollisionMat = new THREE.MeshBasicMaterial({
          color: 0x00ff00,
          wireframe: true,
          transparent: true,
          opacity: 0.25,
        });
        const saberCollisionHelper = new THREE.Mesh(
          saberCollisionGeo,
          saberCollisionMat
        );
        saberCollisionHelper.position.set(0, 0, 0);
        saberHolder.add(saberCollisionHelper);
        debugState.saberCollisionHelper = saberCollisionHelper;

        // Linea che mostra l'orbita prevista del drone
        const orbitPoints = [];
        const segments = 64;
        for (let i = 0; i <= segments; i++) {
          const a = (i / segments) * Math.PI * 2;
          orbitPoints.push(
            new THREE.Vector3(
              Math.cos(a) * droneOrbitRadius,
              droneHeight,
              Math.sin(a) * droneOrbitRadius
            )
          );
        }
        const orbitGeo = new THREE.BufferGeometry().setFromPoints(orbitPoints);
        const orbitMat = new THREE.LineBasicMaterial({ color: 0x333399 });
        const orbitLine = new THREE.Line(orbitGeo, orbitMat);
        scene.add(orbitLine);
        debugState.droneOrbitLine = orbitLine;

        debugLog('DEBUG: ON');
      }

      function updateDebug(dt) {
        if (!debugState.enabled || !debugState.panel) return;

        camera.getWorldPosition(tmpCameraWorldPos);
        drone.getWorldPosition(tmpDroneWorldPos);
        saber.getWorldPosition(tmpSaberWorldPos);

        const line1 = `dt: ${dt.toFixed(3)} s  bolts: ${bolts.length}`;
        const line2 = `cam: (${tmpCameraWorldPos.x.toFixed(2)}, ${tmpCameraWorldPos.y.toFixed(2)}, ${tmpCameraWorldPos.z.toFixed(2)})`;
        const line3 = `drone: (${tmpDroneWorldPos.x.toFixed(2)}, ${tmpDroneWorldPos.y.toFixed(2)}, ${tmpDroneWorldPos.z.toFixed(2)})`;
        const line4 = `saber: (${tmpSaberWorldPos.x.toFixed(2)}, ${tmpSaberWorldPos.y.toFixed(2)}, ${tmpSaberWorldPos.z.toFixed(2)})`;
        const line5 = `angle: ${droneAngle.toFixed(2)} rad`;

        // sovrascrive direttamente il pannello (per evitare accumulo di righe)
        debugState.panel.textContent = [line1, line2, line3, line4, line5].join(
          '\n'
        );
      }

      // chiamiamo subito la setupDebug (non fa niente se DEBUG=false)
      setupDebug();

      // === LOGICA COLPI ===
      function spawnBolt() {
        const bolt = new THREE.Mesh(boltGeo, boltMat.clone());
        drone.getWorldPosition(tmpDroneWorldPos);
        bolt.position.copy(tmpDroneWorldPos);

        // bersaglio vicino alla testa del giocatore con un po' di rumore
        const target = new THREE.Vector3(0, 1.6, 0).add(
          new THREE.Vector3(
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3,
            (Math.random() - 0.5) * 0.3
          )
        );
        const dir = target.clone().sub(tmpDroneWorldPos).normalize();
        const velocity = dir.multiplyScalar(boltSpeed);

        scene.add(bolt);
        bolts.push({ mesh: bolt, velocity, reflected: false });

        if (DEBUG) debugLog('Bolt spawn');
      }

      function updateBolts(dt) {
        camera.getWorldPosition(tmpCameraWorldPos);
        saber.getWorldPosition(tmpSaberWorldPos);

        // direzione della spada (asse locale Y)
        tmpSaberDir.set(0, 1, 0);
        tmpSaberDir.applyQuaternion(saber.getWorldQuaternion());
        tmpSaberDir.normalize();

        for (let i = bolts.length - 1; i >= 0; i--) {
          const bolt = bolts[i];
          bolt.mesh.position.addScaledVector(bolt.velocity, dt);

          // troppo lontano -> elimina
          if (bolt.mesh.position.length() > 30) {
            scene.remove(bolt.mesh);
            bolts.splice(i, 1);
            continue;
          }

          // colpisce il giocatore
          if (
            bolt.mesh.position.distanceTo(tmpCameraWorldPos) < 0.15 &&
            !bolt.reflected
          ) {
            if (DEBUG) debugLog('Player hit!');
            scene.remove(bolt.mesh);
            bolts.splice(i, 1);
            continue;
          }

          // check con la spada (sfera attorno alla spada)
          const d = bolt.mesh.position.distanceTo(tmpSaberWorldPos);
          if (d < SABER_EFFECTIVE_RADIUS && !bolt.reflected) {
            // riflessione
            tmpBoltDir.copy(bolt.velocity).normalize();
            const dot = tmpBoltDir.dot(tmpSaberDir);
            const reflectDir = tmpBoltDir
              .clone()
              .sub(tmpSaberDir.clone().multiplyScalar(2 * dot))
              .normalize();

            bolt.velocity.copy(reflectDir.multiplyScalar(boltSpeed * 1.1));
            bolt.reflected = true;
            bolt.mesh.material.color.setHex(reflectedColor);

            if (DEBUG) debugLog('Bolt deflected');
          }
        }
      }

      // --- LOOP XR ---
      let prevTime = 0;

      renderer.setAnimationLoop((time) => {
        const t = time / 1000;
        const dt = prevTime ? t - prevTime : 0;
        prevTime = t;

        // orbita del drone attorno al giocatore (0, droneHeight, 0)
        droneAngle += droneAngularSpeed * dt;
        const px = Math.cos(droneAngle) * droneOrbitRadius;
        const pz = Math.sin(droneAngle) * droneOrbitRadius;
        drone.position.set(px, droneHeight, pz);

        // guarda verso il centro
        drone.lookAt(0, droneHeight, 0);

        // timer di fuoco
        shootTimer += dt;
        if (shootTimer > shootInterval) {
          shootTimer = 0;
          spawnBolt();
        }

        updateBolts(dt);

        // update debug per frame
        if (DEBUG) updateDebug(dt);

        renderer.render(scene, camera);
      });

      // --- RESPONSIVE ---
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
